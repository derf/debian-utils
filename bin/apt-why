#!/usr/bin/env perl
## Copyright Â© 2008-2009 by Daniel Friesel <derf@derf.homelinux.org>
## License: WTFPL <http://sam.zoy.org/wtfpl>
use strict;
use warnings;
use AptPkg::Cache;
use Switch;
use Getopt::Long;

my $cache = AptPkg::Cache->new;
my $not = 0;
GetOptions(
	"not" => \$not,
);
my $packagename = shift or die("No packagename given");
my @known;

sub revdeps {
	my $name = shift;
	my $package = $cache->{$name};
	my @return;
	my $rdeps = $package->{RevDependsList};
	foreach (@$rdeps) {
		if (
			$cache->{$_->{ParentPkg}{Name}}->{CurrentState} eq 'Installed'
			and $_->{DepType} !~ /^(Conflicts|Replaces|Obsoletes)$/
		) {
			next if ($_->{ParentPkg}{Name} ~~ @known);
			push(@return, $_->{ParentPkg}{Name});
		}
	}
	push(@known, @return);
	return(@return);
}

sub recurse {
	my $name = shift;
	my $level = (shift) + 1;
	printf("%s%s\n", "  " x ($level-1), $name);
	return if ($level >= 5);
	recurse($_, $level) foreach revdeps($name);
}

recurse($packagename, 0);

__END__

=head1 NAME

apt-why - filtered reverse dependency displayer using AptPkg::Cache

=head1 SYNOPSIS

B<apt-why> [ B<--not> ] I<package>

=head1 DESCRIPTION

B<apt-why> displays various informations based on a I<package>s reverse
dependencies

The output is prefixed by two charactes, the former representing the desired
package state, the latter the current state.

The states are I<i>nstall, I<h>old, I<r>emove (deinstall), I<p>urge,
I<u>npacked, halI<f> configured, I<h>alf installed, I<c>onfigfiles installed.
An empty field means not installed.

If B<--not> is specified, reverse dependencies prohibiting the installation of
I<package> are shown. Else, reverse dependencies justifying the installation
of I<package> are shown

=head1 AUTHOR

Daniel Friesel <derf@derf.homelinux.org>

=head1 LICENSE

  0. You just DO WHAT THE FUCK YOU WANT TO.
